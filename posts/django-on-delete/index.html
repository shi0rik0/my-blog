<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous"><meta name="generator" content="Astro v5.1.7"><title></title><link rel="stylesheet" href="/_astro/index.CsOifZER.css"></head> <body class="bg-[#333] text-[#ddd]"> <h1>Sustie</h1> <div class="flex gap-4"> <a href="/">主页</a> <a href="/posts/page/1">所有文章</a> <a href="/search/">文章检索</a> </div>  <h1>Django外键的on_delete参数</h1> <p>在 Django 的 ORM 框架中，通过models.ForeignKey可以很方便地创建外键字段。请看下面的例子：</p>
from django.db import models

class Manufacturer(models.Model):
    name = models.TextField()

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.PROTECT)
<p>在创建外键的时候，必须指定on_delete参数。在早期的 Django 版本中，这个参数有一个默认值CASCADE，而这个选项是非常危险的。假如数据库中有一些 Car 的 Manufacturer 是 BMW，那么如果设置了CASCADE，删除 BMW 就会将由 BMW 生产的所有 Car 的记录也一并删除，这样很可能导致数据丢失。如果设置为PROTECT，就会拒绝这次删除操作，并抛出一个异常。事实上，在生产环境中，往往很少直接删除记录，最多就是用一个专门的deleted字段来进行伪删除，因此将on_delete设置为PROTECT是我心目中的最佳实践。（on_delete还有一些安全性介于CASCADE和PROTECT之间的选项，例如SET_NULL和RESTRICT等等，这里就不赘述了。）</p>  </body></html>