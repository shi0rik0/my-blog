<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.1.7"><title></title><link rel="stylesheet" href="/_astro/index.CsOifZER.css"></head> <body class="bg-[#333] text-[#ddd]"> <h1>Sustie</h1> <div class="flex gap-4"> <a href="/">主页</a> <a href="/posts/">所有文章</a> <a href="/search/">文章检索</a> </div>  <h1>关于Docker的当前目录</h1> <p>最近被 Docker 的当前目录位置整得有些混乱，特地在此整理一下。</p> <h2>Docker Build</h2> <p>执行<code>docker build</code>命令的时候，需要传入一个 positional 参数，这个参数就是 context。举个例子，假如当前 shell 的目录是<code>/root</code>，我们执行以下命令：</p> <pre><code class="language-bash">docker build -f dockerfiles/a.Dockerfile dockerfiles
</code></pre> <p>那么，构建过程中 Dockerfile 的 context 就是<code>/root/dockerfiles</code>。Context 的值会有以下三个影响：</p> <ol> <li>Context 的值就是 Dockerfile 中<code>.</code>所代表的目录。</li> <li>Docker 会将 context 目录下的所有文件（除了被.dockerignore 排除的）复制一遍。在构建镜像的时候，<code>COPY</code>命令只能访问到 context 下的文件。<strong>这里有一个坑点</strong>：假如我们将 context 设置成/root，那么在 Dockerfile 中访问<code>../tmp/a.txt</code>的时候不会立刻报错，而是会访问<code>/root/tmp/a.txt</code>。</li> <li>Docker 在查找全局的.dockerignore 的时候，也是会在 context 目录下查找。但是这里又有一个坑点：Docker 还支持针对某个特定 Dockerfile 的.dockerignore，假设 Dockerfile 文件名为<code>foo.Dockerfile</code>，那么对应的.dockerignore 文件名就是<code>foo.Dockerfile.dockerignore</code>，但是这种.dockerignore 是在 Dockerfile 文件所在的目录下查找，而非 context 目录。举例来说，假如 Dockerfile 是<code>/root/dockerfiles/a.Dockerfile</code>，context 设置为<code>/root</code>，那么生效的.dockerignore 路径就是<code>/root/.dockerignore</code>以及<code>/root/dockerfiles/a.Dockerfile.dockerignore</code>。</li> </ol> <h2>Docker Compose</h2> <p>Docker Compose 的当前目录是<code>docker-compose.yml</code>配置文件所在的目录，而<strong>不是</strong>执行<code>docker compose</code>命令时 shell 的当前目录，并且没有选项可以更改它。</p> <p>但是这里又有一个坑点：在 Docker Compose 的配置文件中可以指定从本地的 Dockerfile 构建镜像，例如：</p> <pre><code class="language-yaml">services:
  service-0:
    build:
      context: ..
      dockerfile: docker/Dockerfile
</code></pre> <p>这里面的<code>context</code>选项是相对于<code>docker-compose.yml</code>所在目录的，但是<code>dockerfile</code>选项却是相对于<code>context</code>的。也就是说，假如上面的配置文件位于<code>/foo/docker-compose.yml</code>，那么<code>context</code>就是<code>/</code>，而 Dockerfile 应该位于<code>/docker/Dockerfile</code>。</p>  </body></html>