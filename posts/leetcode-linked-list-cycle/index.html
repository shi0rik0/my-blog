<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- KaTeX --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous"><!-- Prism --><link href="/lib/prism.css" rel="stylesheet"><script src="/lib/prism.js"></script><meta name="generator" content="Astro v5.1.7"><title></title><link rel="stylesheet" href="/_astro/index.CsOifZER.css"></head> <body class="bg-[#333] text-[#ddd]"> <h1>Sustie</h1> <div class="flex gap-4"> <a href="/">主页</a> <a href="/posts/page/1">所有文章</a> <a href="/search/">文章检索</a> </div>  <h1>LeetCode题解：环路检测</h1> <p>原题网址：https://leetcode.cn/problems/linked-list-cycle-lcci/</p> <h2>解题思路</h2> <p>这道题目就是经典的<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare">Floyd龟兔赛跑算法</a>。这个算法主要分为两个部分，第一个部分就是如何判定是否有环，第二个部分就是如何找到环的起点。第一个部分比较简单，很容易理解，因此也很脍炙人口。但是第二个部分就比较少人知道了，因为其推导过程相对复杂一些，具体可以参考<a href="https://leetcode.cn/problems/linked-list-cycle-lcci/solutions/531787/huan-lu-jian-ce-by-leetcode-solution-s2la/">LeetCode官方的题解</a>。</p> <h2>代码实现</h2> <pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if head is None:
            return None
        slow = head.next
        if slow is None:
            return None
        fast = slow.next
        if fast is None:
            return None
        while slow is not fast:
            for _ in range(2):
                fast = fast.next
                if fast is None:
                    return None
            slow = slow.next
        third = head
        while third is not slow:
            slow = slow.next
            third = third.next
        return slow
</code></pre>  </body></html>